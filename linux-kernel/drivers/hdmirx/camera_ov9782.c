#include <linux/i2c.h>
#include <linux/slab.h>
#include <linux/videodev2.h>

#include "phoenix_mipi_i2c_ctl.h"
#include "phoenix_hdmiInternal.h"

static unsigned int cur_fps = CAMERA_FPS30;
static struct group_switch_config g_config = {
	.enable_group = 0,
	.update_group = 0x3,
	.expo0_19_16 = 0x0,
	.expo0_15_8 = 0x65,
	.expo0_7_0 = 0x80,
	.gain0 = 0x10,
	.expo1_19_16 = 0x0,
	.expo1_15_8 = 0x19,
	.expo1_7_0 = 0x60,
	.gain1 = 0x80
};

static struct awb_gain_config awb_config = {
	.red_gain_11_8 = 0x06,
	.red_gain_7_0 = 0x00,
	.green_gain_11_8 = 0x04,
	.green_gain_7_0 = 0x00,
	.blue_gain_11_8 = 0x0b,
	.blue_gain_7_0 = 0x00,
};

void OV9782_set_frame_rate(unsigned int fps, int stream_on);
int OV9782_set_group(struct group_switch_config *config, int stream_on);
int OV9782_set_awb(struct awb_gain_config *gain, int stream_on);


/*OV9782 MIPI_2lane_1280x720(RAW8) 30fps */
const unsigned char fw_ov9782_1280x720_raw8[] = {
	0x01, 0x03, 0x01,
	0x03, 0x02, 0x32,
	0x03, 0x0d, 0x50,
	0x03, 0x0e, 0x02,
	0x30, 0x01, 0x00,
	0x30, 0x04, 0x00,
	0x30, 0x05, 0x00,
	0x30, 0x06, 0x04,
	0x30, 0x11, 0x0a,
	0x30, 0x13, 0x18,
	0x30, 0x1c, 0xf0,
	0x30, 0x22, 0x01,
	0x30, 0x30, 0x10,
	0x30, 0x39, 0x32,
	0x30, 0x3a, 0x00,
	0x35, 0x00, 0x00,
	0x35, 0x01, 0x2a,
	0x35, 0x02, 0x90,
	0x35, 0x03, 0x08,
	0x35, 0x05, 0x8c,
	0x35, 0x07, 0x03,
	0x35, 0x08, 0x00,
	0x35, 0x09, 0x10,
	0x36, 0x10, 0x80,
	0x36, 0x11, 0xa0,
	0x36, 0x20, 0x6e,
	0x36, 0x32, 0x56,
	0x36, 0x33, 0x78,
	0x36, 0x62, 0x05,
	0x36, 0x66, 0x00,
	0x36, 0x6f, 0x5a,
	0x36, 0x80, 0x84,
	0x37, 0x12, 0x80,
	0x37, 0x2d, 0x22,
	0x37, 0x31, 0x80,
	0x37, 0x32, 0x30,
	0x37, 0x78, 0x00,
	0x37, 0x7d, 0x22,
	0x37, 0x88, 0x02,
	0x37, 0x89, 0xa4,
	0x37, 0x8a, 0x00,
	0x37, 0x8b, 0x4a,
	0x37, 0x99, 0x20,
	0x38, 0x00, 0x00,
	0x38, 0x01, 0x00,
	0x38, 0x02, 0x00,
	0x38, 0x03, 0x00,
	0x38, 0x04, 0x05,
	0x38, 0x05, 0x0f,
	0x38, 0x06, 0x03,
	0x38, 0x07, 0x2f,
	0x38, 0x08, 0x05,
	0x38, 0x09, 0x00,
	0x38, 0x0a, 0x02,
	0x38, 0x0b, 0xd0,
	0x38, 0x0c, 0x02,
	0x38, 0x0d, 0xd8,
	0x38, 0x0e, 0x0e,
	0x38, 0x0f, 0x4f,
	0x38, 0x10, 0x00,
	0x38, 0x11, 0x08,
	0x38, 0x12, 0x00,
	0x38, 0x13, 0x08,
	0x38, 0x14, 0x11,
	0x38, 0x15, 0x11,
	0x38, 0x20, 0x40,
	0x38, 0x21, 0x00,
	0x38, 0x2c, 0x05,
	0x38, 0x2d, 0xb0,
	0x38, 0x9d, 0x00,
	0x38, 0x81, 0x42,
	0x38, 0x82, 0x01,
	0x38, 0x83, 0x00,
	0x38, 0x85, 0x02,
	0x38, 0xa8, 0x02,
	0x38, 0xa9, 0x80,
	0x38, 0xb1, 0x00,
	0x38, 0xb3, 0x02,
	0x38, 0xc4, 0x00,
	0x38, 0xc5, 0xc0,
	0x38, 0xc6, 0x04,
	0x38, 0xc7, 0x80,
	0x39, 0x20, 0xff,
	0x40, 0x03, 0x40,
	0x40, 0x08, 0x04,
	0x40, 0x09, 0x0b,
	0x40, 0x0c, 0x00,
	0x40, 0x0d, 0x07,
	0x40, 0x10, 0x40,
	0x40, 0x43, 0x40,
	0x43, 0x07, 0x30,
	0x43, 0x17, 0x00,
	0x45, 0x01, 0x00,
	0x45, 0x07, 0x00,
	0x45, 0x09, 0x00,
	0x45, 0x0a, 0x08,
	0x46, 0x01, 0x04,
	0x47, 0x0f, 0x00,
	0x4f, 0x07, 0x00,
	0x48, 0x00, 0x00,
	0x50, 0x00, 0x9f,
	0x50, 0x01, 0x00,
	0x5e, 0x00, 0x00,
	0x5d, 0x00, 0x07,
	0x5d, 0x01, 0x00,
	0x4f, 0x00, 0x04,
	0x4f, 0x10, 0x00,
	0x4f, 0x11, 0x98,
	0x4f, 0x12, 0x0f,
	0x4f, 0x13, 0xc4,
	0x01, 0x00, 0x01,
	0x35, 0x01, 0x38,
	0x35, 0x02, 0x20,
#if 1
	/* White Balance for TL84 */
	0x34, 0x00, 0x06,
	0x34, 0x01, 0x00,
	0x34, 0x02, 0x04,
	0x34, 0x03, 0x00,
	0x34, 0x04, 0x0b,
	0x34, 0x05, 0x00,
#endif
	/* RAW8 */
	0x01, 0x00, 0x00,
	0x36, 0x62, 0x07,
	0x48, 0x37, 0x14,
	0x46, 0x01, 0x4f,
	0x01, 0x00, 0x01,
#if 1/* Embedded line(first line) */
	0x01, 0x00, 0x00,
	0x48, 0x14, 0x6b,
	0x43, 0x07, 0x31,
	0x36, 0x6f, 0x1a,
	0x36, 0x62, 0x05,
	0x46, 0x01, 0xa0,
	0x01, 0x00, 0x01,
#endif
#if 0/* ColorBar */
	0x5e, 0x00, 0x80,
#endif
};

/* R1280x800+1EML RAW10 59.98fps MIPI_2lane */
const unsigned char fw_ov9782_1280x800_raw10[] = {
	0x01, 0x03, 0x01,
	0x03, 0x02, 0x32,
	0x03, 0x0d, 0x50,
	0x03, 0x0e, 0x02,
	0x30, 0x01, 0x00,
	0x30, 0x04, 0x00,
	0x30, 0x05, 0x00,
	0x30, 0x06, 0x04,
	0x30, 0x11, 0x0a,
	0x30, 0x13, 0x18,
	0x30, 0x1c, 0xf0,
	0x30, 0x22, 0x01,
	0x30, 0x30, 0x10,
	0x30, 0x39, 0x32,
	0x30, 0x3a, 0x00,
	0x35, 0x00, 0x00,
	0x35, 0x01, 0x2a,
	0x35, 0x02, 0x90,
	0x35, 0x03, 0x08,
	0x35, 0x05, 0x8c,
	0x35, 0x07, 0x03,
	0x35, 0x08, 0x00,
	0x35, 0x09, 0x10,
	0x36, 0x10, 0x80,
	0x36, 0x11, 0xa0,
	0x36, 0x20, 0x6e,
	0x36, 0x32, 0x56,
	0x36, 0x33, 0x78,
	0x36, 0x62, 0x05,
	0x36, 0x66, 0x00,
	0x36, 0x6f, 0x5a,
	0x36, 0x80, 0x84,
	0x37, 0x12, 0x80,
	0x37, 0x2d, 0x22,
	0x37, 0x31, 0x80,
	0x37, 0x32, 0x30,
	0x37, 0x78, 0x00,
	0x37, 0x7d, 0x22,
	0x37, 0x88, 0x02,
	0x37, 0x89, 0xa4,
	0x37, 0x8a, 0x00,
	0x37, 0x8b, 0x4a,
	0x37, 0x99, 0x20,
	0x38, 0x00, 0x00,
	0x38, 0x01, 0x00,
	0x38, 0x02, 0x00,
	0x38, 0x03, 0x00,
	0x38, 0x04, 0x05,
	0x38, 0x05, 0x0f,
	0x38, 0x06, 0x03,
	0x38, 0x07, 0x2f,
	0x38, 0x08, 0x05,
	0x38, 0x09, 0x00,
	0x38, 0x0a, 0x03,
	0x38, 0x0b, 0x20,
	0x38, 0x0c, 0x02,
	0x38, 0x0d, 0xd8,
	0x38, 0x0e, 0x0e,
	0x38, 0x0f, 0x4f,
	0x38, 0x10, 0x00,
	0x38, 0x11, 0x08,
	0x38, 0x12, 0x00,
	0x38, 0x13, 0x08,
	0x38, 0x14, 0x11,
	0x38, 0x15, 0x11,
	0x38, 0x20, 0x40,
	0x38, 0x21, 0x00,
	0x38, 0x2c, 0x05,
	0x38, 0x2d, 0xb0,
	0x38, 0x9d, 0x00,
	0x38, 0x81, 0x42,
	0x38, 0x82, 0x01,
	0x38, 0x83, 0x00,
	0x38, 0x85, 0x02,
	0x38, 0xa8, 0x02,
	0x38, 0xa9, 0x80,
	0x38, 0xb1, 0x00,
	0x38, 0xb3, 0x02,
	0x38, 0xc4, 0x00,
	0x38, 0xc5, 0xc0,
	0x38, 0xc6, 0x04,
	0x38, 0xc7, 0x80,
	0x39, 0x20, 0xff,
	0x40, 0x03, 0x40,
	0x40, 0x08, 0x04,
	0x40, 0x09, 0x0b,
	0x40, 0x0c, 0x00,
	0x40, 0x0d, 0x07,
	0x40, 0x10, 0x40,
	0x40, 0x43, 0x40,
	0x43, 0x07, 0x30,
	0x43, 0x17, 0x00,
	0x45, 0x01, 0x00,
	0x45, 0x07, 0x00,
	0x45, 0x09, 0x00,
	0x45, 0x0a, 0x08,
	0x46, 0x01, 0x04,
	0x47, 0x0f, 0x00,
	0x4f, 0x07, 0x00,
	0x48, 0x00, 0x00,
	0x50, 0x00, 0x9f,
	0x50, 0x01, 0x00,
	0x5e, 0x00, 0x00,
	0x5d, 0x00, 0x07,
	0x5d, 0x01, 0x00,
	0x4f, 0x00, 0x04,
	0x4f, 0x10, 0x00,
	0x4f, 0x11, 0x98,
	0x4f, 0x12, 0x0f,
	0x4f, 0x13, 0xc4,
	/* White Balance for TL84 */
	0x34, 0x00, 0x06,
	0x34, 0x01, 0x00,
	0x34, 0x02, 0x04,
	0x34, 0x03, 0x00,
	0x34, 0x04, 0x0b,
	0x34, 0x05, 0x00,
	0x48, 0x37, 0x14,
	/* Embedded line */
	0x48, 0x14, 0x6b,
	0x43, 0x07, 0x31,
	0x36, 0x6f, 0x1a,
	0x36, 0x62, 0x05,
	0x01, 0x00, 0x01,
};

int OV9782_write_reg(struct i2c_adapter *p_adap,
	unsigned int addr, unsigned char val)
{
	int ret_val;
	unsigned char data[3];

	data[0] = (unsigned char)(addr >> 8);
	data[1] = (unsigned char)(addr & 0xFF);
	data[2] = val;
	ret_val = mipi_i2c_write(p_adap, 3, data);

	return ret_val;
}


void OV9782_2lane_1280x720_raw8(void)
{
	struct i2c_adapter *p_adap;
	unsigned int i;
	unsigned char data[3];

	pr_info("[MIPI] %s\n", __func__);
	p_adap = mipi_i2c_init();

	if (p_adap == NULL) {
		pr_err("[MIPI][%s] Init i2c fail\n", __func__);
		return;
	}

	for(i = 0; i < sizeof(fw_ov9782_1280x720_raw8); i += 3) {
		data[0] = fw_ov9782_1280x720_raw8[i];
		data[1] = fw_ov9782_1280x720_raw8[i+1];
		data[2] = fw_ov9782_1280x720_raw8[i+2];
		mipi_i2c_write(p_adap, 3, data);
	}

#if 0/* Dump register */
	for(i = 0; i < sizeof(fw_ov9782_1280x720_raw8); i += 3) {
		data[0] = fw_ov9782_1280x720_raw8[i];
		data[1] = fw_ov9782_1280x720_raw8[i+1];
		mipi_i2c_read(p_adap, 1, &data);
		pr_err("Reg%02x%02x=%02x",
			fw_ov9782_1280x720_raw8[i], fw_ov9782_1280x720_raw8[i+1], data[0]);
	}
#endif
}

int OV9782_2lane_1280x800(unsigned int color)
{
	int ret_value;
	struct i2c_adapter *p_adap;
	unsigned int i;
	unsigned char data[3];

	pr_info("[MIPI][%s] %s\n",
		__func__, (color == OUT_RAW10)?"RAW10":"RAW8");

	p_adap = mipi_i2c_init();

	if (p_adap == NULL) {
		pr_err("[MIPI][%s] Init i2c fail\n", __func__);
		return -1;
	}

	for(i = 0; i < sizeof(fw_ov9782_1280x800_raw10); i += 3) {
		data[0] = fw_ov9782_1280x800_raw10[i];
		data[1] = fw_ov9782_1280x800_raw10[i+1];
		data[2] = fw_ov9782_1280x800_raw10[i+2];
		ret_value = mipi_i2c_write(p_adap, 3, data);
		if (ret_value < 0) {
			pr_err("[MIPI][%s] access i2c fail\n", __func__);
			return -1;
		}
	}

	if (color == OUT_RAW8) {
		OV9782_write_reg(p_adap, 0x0100, 0x00);
		OV9782_write_reg(p_adap, 0x3662, 0x07);
		OV9782_write_reg(p_adap, 0x4837, 0x14);
		OV9782_write_reg(p_adap, 0x4601, 0x4f);
#if 1/* Embedded line(first line) */
		OV9782_write_reg(p_adap, 0x4814, 0x6a);
		OV9782_write_reg(p_adap, 0x4307, 0x31);
		OV9782_write_reg(p_adap, 0x366f, 0x1a);
		OV9782_write_reg(p_adap, 0x3662, 0x07);
		OV9782_write_reg(p_adap, 0x4601, 0x80);
#endif
		OV9782_write_reg(p_adap, 0x0100, 0x01);
	}

	if (cur_fps != CAMERA_FPS30)
		OV9782_set_frame_rate(cur_fps, 1);

	if ((g_config.enable_group != 0) ||
		(g_config.update_group != 0x3) ||
		(g_config.expo0_19_16 != 0x0) ||
		(g_config.expo0_15_8 != 0x65) || (g_config.expo0_7_0 != 0x80) ||
		(g_config.gain0 != 0x10) ||
		(g_config.expo1_19_16 != 0x0) ||
		(g_config.expo1_15_8 != 0x19) || (g_config.expo1_7_0 != 0x60) ||
		(g_config.gain1 != 0x80)) {
		OV9782_set_group(&g_config, 1);
	}

	if ((awb_config.blue_gain_11_8 != 0x06) ||
		(awb_config.blue_gain_7_0 != 0x00) ||
		(awb_config.green_gain_11_8 != 0x04) ||
		(awb_config.green_gain_7_0 != 0x00) ||
		(awb_config.red_gain_11_8 != 0x0b) ||
		(awb_config.red_gain_7_0 != 0x00)) {
		OV9782_set_awb(&awb_config, 1);
	}
	return 0;
}

unsigned int OV9782_get_frame_rate(void)
{
	return cur_fps;
}

void OV9782_set_frame_rate(unsigned int fps, int stream_on)
{
	struct i2c_adapter *p_adap;
	unsigned int cam_fps;
	unsigned char vts_h, vts_l;

	pr_info("[MIPI][%s] %u\n", __func__, fps);

	if (fps <= CAMERA_FPS15)
		cam_fps = CAMERA_FPS15;
	else if (fps <= CAMERA_FPS25)
		cam_fps = CAMERA_FPS25;
	else if (fps <= CAMERA_FPS30)
		cam_fps = CAMERA_FPS30;
	else if (fps <= CAMERA_FPS60)
		cam_fps = CAMERA_FPS60;
	else if (fps <= CAMERA_FPS100)
		cam_fps = CAMERA_FPS100;
	else
		cam_fps = CAMERA_FPS120;

	if (stream_on == 0) {
		cur_fps = cam_fps;
		return;
	}

	p_adap = mipi_i2c_init();

	if (p_adap == NULL) {
		pr_err("[MIPI][%s] Init i2c fail\n", __func__);
		return;
	}

	/* Stop streaming */
	OV9782_write_reg(p_adap, 0x0100, 0x00);

	switch (cam_fps) {
	case CAMERA_FPS15:
		vts_h = 0x1c;
		vts_l = 0x70;
		cur_fps = CAMERA_FPS15;
		break;
	case CAMERA_FPS25:
		vts_h = 0x11;
		vts_l = 0x2a;
		cur_fps = CAMERA_FPS25;
		break;
	case CAMERA_FPS30:
		vts_h = 0x0e;
		vts_l = 0x4f;
		cur_fps = CAMERA_FPS30;
		break;
	case CAMERA_FPS60:
		vts_h = 0x07;
		vts_l = 0x1c;
		cur_fps = CAMERA_FPS60;
		break;
	case CAMERA_FPS100:
		vts_h = 0x04;
		vts_l = 0x44;
		cur_fps = CAMERA_FPS100;
		break;
	case CAMERA_FPS120:
		vts_h = 0x03;
		vts_l = 0x8e;
		cur_fps = CAMERA_FPS120;
		break;
	default:
		vts_h = 0x07;
		vts_l = 0x1c;
		cur_fps = CAMERA_FPS60;
		break;
	}

	/* Vertical Timing Size High Byte */
	OV9782_write_reg(p_adap, 0x380e, vts_h);

	/* Vertical Timing Size Low Byte */
	OV9782_write_reg(p_adap, 0x380f, vts_l);

	/* Start streaming */
	OV9782_write_reg(p_adap, 0x0100, 0x01);

}

int OV9782_set_group(struct group_switch_config *config, int stream_on)
{
	struct i2c_adapter *p_adap;

	/* pr_info("[MIPI] %s\n", __func__); */

	p_adap = mipi_i2c_init();
	if (p_adap == NULL) {
		pr_err("[MIPI][%s] Init i2c fail\n", __func__);
		goto err_ret;
	}

	g_config.enable_group = config->enable_group;
	g_config.update_group = config->update_group;
	g_config.expo0_19_16 = config->expo0_19_16;
	g_config.expo0_15_8 = config->expo0_15_8;
	g_config.expo0_7_0 = config->expo0_7_0;
	g_config.gain0 = config->gain0;
	g_config.expo1_19_16 = config->expo1_19_16;
	g_config.expo1_15_8 = config->expo1_15_8;
	g_config.expo1_7_0 = config->expo1_7_0;
	g_config.gain1 = config->gain1;

#if 0/* Dump group setting */
	pr_info("enable_group = 0x%02x\n", g_config.enable_group);
	pr_info("update_group = 0x%02x\n", g_config.update_group);
	pr_info("expo0_19_16 = 0x%02x\n", g_config.expo0_19_16);
	pr_info("expo0_15_8 = 0x%02x\n", g_config.expo0_15_8);
	pr_info("expo0_7_0 = 0x%02x\n", g_config.expo0_7_0);
	pr_info("gain0 = 0x%02x\n", g_config.gain0);
	pr_info("expo1_19_16 = 0x%02x\n", g_config.expo1_19_16);
	pr_info("expo1_15_8 = 0x%02x\n", g_config.expo1_15_8);
	pr_info("expo1_7_0 = 0x%02x\n", g_config.expo1_7_0);
	pr_info("gain1 = 0x%02x\n", g_config.gain1);
#endif

	if (stream_on == 0)
		goto exit;

	/* Switch off & update group registers */
	if (OV9782_write_reg(p_adap, 0x320b, 0x00))
		goto err_ret;

	if (config->update_group & 0x1) {
		/* Change exposure and gain of context 0 */
		/* Hold staring of context 0 group register */
		OV9782_write_reg(p_adap, 0x3208, 0x00);

		/* Set exporsure time*/
		//OV9782_write_reg(p_adap, 0x3500, config->expo0_19_16);
		OV9782_write_reg(p_adap, 0x3501, config->expo0_15_8);
		OV9782_write_reg(p_adap, 0x3502, config->expo0_7_0);

		/* Set gain */
		OV9782_write_reg(p_adap, 0x3509, config->gain0);

		/* Hold end of context 0 group register */
		OV9782_write_reg(p_adap, 0x3208, 0x10);
	}

	if (config->update_group & 0x2) {
		/* Change exposure and gain of context 1 */
		/* Hold staring of context 1 group register */
		OV9782_write_reg(p_adap, 0x3208, 0x01);

		/* Set exporsure time*/
		//OV9782_write_reg(p_adap, 0x3500, config->expo1_19_16);
		OV9782_write_reg(p_adap, 0x3501, config->expo1_15_8);
		OV9782_write_reg(p_adap, 0x3502, config->expo1_7_0);

		/* Set gain */
		OV9782_write_reg(p_adap, 0x3509, config->gain1);

		/* Hold end of context 1 group register */
		OV9782_write_reg(p_adap, 0x3208, 0x11);
	}

	/* Todo : Following line is for experiment and should be removed after final specification is fixed */
	/* Start switching */
	OV9782_write_reg(p_adap, 0x320b, 0x00);

	if (config->enable_group)
		OV9782_write_reg(p_adap, 0x320b, 0x1d);
	else
		OV9782_write_reg(p_adap, 0x320b, 0x01);

	OV9782_write_reg(p_adap, 0x3208, 0xa0);

exit:
	return 0;
err_ret:
	return -1;
}

void OV9782_get_group(struct group_switch_config *config)
{
	/* pr_info("[MIPI] %s\n", __func__); */

	if (config == NULL)
		return;

	config->enable_group = g_config.enable_group;
	config->update_group = g_config.update_group;
	config->expo0_19_16 = g_config.expo0_19_16;
	config->expo0_15_8 = g_config.expo0_15_8;
	config->expo0_7_0 = g_config.expo0_7_0;
	config->gain0 = g_config.gain0;
	config->expo1_19_16 = g_config.expo1_19_16;
	config->expo1_15_8 = g_config.expo1_15_8;
	config->expo1_7_0 = g_config.expo1_7_0;
	config->gain1 = g_config.gain1;

}

int OV9782_set_awb(struct awb_gain_config *gain, int stream_on)
{
	struct i2c_adapter *p_adap;

	/* pr_info("[MIPI] %s\n", __func__); */

	p_adap = mipi_i2c_init();
	if (p_adap == NULL) {
		pr_err("[MIPI][%s] Init i2c fail\n", __func__);
		goto err_ret;
	}

	awb_config.red_gain_11_8 = gain->red_gain_11_8;
	awb_config.red_gain_7_0 = gain->red_gain_7_0;
	awb_config.green_gain_11_8 = gain->green_gain_11_8;
	awb_config.green_gain_7_0 = gain->green_gain_7_0;
	awb_config.blue_gain_11_8 = gain->blue_gain_11_8;
	awb_config.blue_gain_7_0 = gain->blue_gain_7_0;

	if (stream_on == 0)
		goto exit;

	if (OV9782_write_reg(p_adap, 0x3400, gain->red_gain_11_8))
		goto err_ret;
	OV9782_write_reg(p_adap, 0x3401, gain->red_gain_7_0);
	OV9782_write_reg(p_adap, 0x3402, gain->green_gain_11_8);
	OV9782_write_reg(p_adap, 0x3403, gain->green_gain_7_0);
	OV9782_write_reg(p_adap, 0x3404, gain->blue_gain_11_8);
	OV9782_write_reg(p_adap, 0x3405, gain->blue_gain_7_0);

exit:
	return 0;
err_ret:
	return -1;
}

void OV9782_get_awb(struct awb_gain_config *gain)
{
	/* pr_info("[MIPI] %s\n", __func__); */

	if (gain == NULL)
		return;

	gain->red_gain_11_8 = awb_config.red_gain_11_8;
	gain->red_gain_7_0 = awb_config.red_gain_7_0;
	gain->green_gain_11_8 = awb_config.green_gain_11_8;
	gain->green_gain_7_0 = awb_config.green_gain_7_0;
	gain->blue_gain_11_8 = awb_config.blue_gain_11_8;
	gain->blue_gain_7_0 = awb_config.blue_gain_7_0;
}
