#include <linux/i2c.h>
#include <linux/slab.h>

#include "phoenix_mipi_i2c_ctl.h"

/* RLE0551C 4lane_2048x1536(YUV) */
const unsigned char fw_data_2048x1536[]={
	/* patterngen_A */
	0x04, 0x2a, 0x00,
	0x04, 0x10, 0x00,
	0x04, 0x09, 0x01,
	/* patterngen_B */
	0x04, 0x00, 0x01,
	0x04, 0x67, 0x00,
	0x03, 0x1a, 0x00,
	/* patterngen_C */
	0x02, 0x1a, 0x00,
	/* patterngen_D */
	0x04, 0x26, 0x00,
	0x04, 0x15, 0x00,
	0x04, 0x24, 0x00,
	/* patterngen_E */
	0x04, 0x2e, 0x00,
	0x04, 0x34, 0x00,
	0x04, 0x35, 0x00,
	/* patterngen_F */
	0x04, 0x36, 0x1f,
	0x04, 0x37, 0x00,
	/* patterngen_G */
	0x02, 0x00, 0x10,
	0x02, 0x01, 0x00,
	0x02, 0x02, 0x06,
	/* patterngen_H */
	0x02, 0x03, 0x00,
	0x02, 0x04, 0x00,
	0x02, 0x05, 0xac,
	/* patterngen_I */
	0x02, 0x06, 0x00,
	0x02, 0x07, 0x0a,
	/* patterngen_J */
	0x02, 0x08, 0x00,
	0x02, 0x09, 0x00,
	/* patterngen_K */
	0x03, 0x03, 0x00,
	0x03, 0x04, 0x31,
	/* patterngen_L */
	0x03, 0x05, 0x04,
	0x03, 0x06, 0x03,
	/* patterngen_M */
	0x03, 0x07, 0x0d,
	0x03, 0x08, 0x09,
	/* patterngen_N */
	0x03, 0x09, 0x1d,
	0x03, 0x0a, 0x01,
	/* patterngen_O */
	0x03, 0x0b, 0x03,
	0x03, 0x0c, 0x03,
	/* patterngen_P */
	0x03, 0x0d, 0x03,
	0x03, 0x0e, 0x02,
	/* patterngen_Q */
	0x03, 0x0f, 0x00,
	0x03, 0x01, 0x00,
	0x03, 0x11, 0x00,
	/* patterngen_R */
	0x03, 0x02, 0xc3,
	0x03, 0x17, 0x03,
	0x03, 0x19, 0x1e,
	/* patterngen_S */
	0x03, 0x18, 0xe4,
	0x04, 0x18, 0x07,
	0x03, 0x00, 0x01,
	/* patterngen_T */
	0x02, 0x11, 0x70,
	0x02, 0x12, 0xa0,
	0x02, 0x13, 0x00,
	/* patterngen_U */
	0x02, 0x14, 0x10,
	0x02, 0x15, 0x10,
	0x02, 0x16, 0x11,
	/* patterngen_V */
	0x02, 0x17, 0x10,
	0x02, 0x18, 0x10,
	0x02, 0x19, 0x00,
	/* patterngen_W */
	0x02, 0x10, 0xc0,
};

/* RLE0551C 1280x720p30 RAW8 2Lane */
const unsigned char fw_rle0551_1280x720_raw8[] = {
	0x04, 0x2a, 0x00,
	0x04, 0x10, 0x00, /* Bad gap On */
	0x04, 0x09, 0x01, /* Tx PLL On, post-div disable */
	0x04, 0x00, 0x01, /* Tx analog power on */
	0x04, 0x67, 0x00, /* clk_src = mipi_clk/2 */
	0x03, 0x1a, 0x00, /* MUST, tx clk = clk_src/4=mipi_clk/8 */
	0x02, 0x1a, 0x00, /* Fp clk = clk_src = mipi_clk/2,  max Fp_clk < 250MHz */
	/* mipi_clk = 12*(8+2+0)/1/1= 120 (MHz) */
	0x04, 0x26, 0x00,
	0x04, 0x15, 0x00, /* DSI_RG_CMU_PREDV = 0 */
	0x04, 0x24, 0x00, /* DSI_RG_CMU_PSTDV = 0, bypass PstDV */
	0x04, 0x2E, 0x00, /*  bypass PstDV */
	0x04, 0x34, 0x00, /* DSI_RG_SSC_FC =0 */
	0x04, 0x35, 0x00,
	0x04, 0x36, 0x08, /* DSI_RG_SSC_NC = 8 -->  mipi_clk = 120MHz[10/12] */
	0x04, 0x37, 0x00,
	/* Assume Pclk*16 < Tx_clk *8 * lane_num, when raw10 */
	/* Pclk = fp_clk*Frame_width/((Frame_width*(speed_div+1)/(speed_mul+1)+dummy_pix) */
	0x02, 0x00, 0x05, /* frame width 1280  [10/11] */
	0x02, 0x01, 0x00,
	0x02, 0x02, 0x02, /* frame height 720 */
	0x02, 0x03, 0xD0,
	0x02, 0x04, 0x05, /* dumy pixel 1424 */
	0x02, 0x05, 0x90,
	0x02, 0x06, 0x00, /* dumy line 20 */
	0x02, 0x07, 0x14,
	0x02, 0x08, 0x00, /* # speed 0 */
	0x02, 0x09, 0x00,
	/* Tx timing control */
	0x03, 0x03, 0x00, /* TX init time */
	0x03, 0x04, 0x31,
	0x03, 0x05, 0x04, /* HS exit time,[4/10] */
	0x03, 0x06, 0x03, /* Tx LPx time,[4/10] */
	0x03, 0x07, 0x0D, /* CK post time */
	0x03, 0x08, 0x09, /* CK prepare time */
	0x03, 0x09, 0x1D, /* CK zero time */
	0x03, 0x0A, 0x01, /* CK pre time */
	0x03, 0x0B, 0x03, /* HS prepare time,[4/10] */
	0x03, 0x0C, 0x03, /* HS zero time,[4/10] */
	0x03, 0x0D, 0x03, /* HS trail time,[4/10] */
	0x03, 0x0E, 0x02, /* Tx valid time,[4/10] */
	/* Tx control */
	0x03, 0x0F, 0x00, /* Tx IF CFG0, enable LANE */
	0x03, 0x01, 0x00, /* MIPI tx data raw8 ,[4/16] */
	0x03, 0x02, 0x03, /* Lane0/1 enable */
	0x03, 0x11, 0x00, /* data from fix pattern */
	0x03, 0x17, 0x01, /* 2 lane */
	0x03, 0x18, 0xE4,
	0x03, 0x19, 0x2A, /* set DI as 0x2A, raw8, [4/16] */
	0x04, 0x18, 0x07, /* set HS amp to 440mV */
	0x03, 0x00, 0x01, /* Tx enable */
	/* pattern run */
	0x02, 0x11, 0x80, /* start x, y, [4/9] */
	0x02, 0x12, 0xff,
	0x02, 0x13, 0x00,
	0x02, 0x14, 0xd0, /* width, height, [4/9] */
	0x02, 0x15, 0xd0,
	0x02, 0x16, 0x11,
	0x02, 0x17, 0x20, /* Margin, [4/9] */
	0x02, 0x18, 0x20,
	0x02, 0x19, 0x00,
	0x02, 0x10, 0x80, /* fixed pattern start,RAW8, 24 color,[4/16] */
};

/* RLE0551C 1280x720p30 YUV422 2Lane */
const unsigned char fw_rle0551_1280x720_yuv2[] = {
	0x04, 0x2a, 0x00,
	0x04, 0x10, 0x00, /* Bad gap On */
	0x04, 0x09, 0x01, /* Tx PLL On, post-div disable */
	0x04, 0x00, 0x01, /* Tx analog power on */
	0x04, 0x67, 0x00, /* clk_src = mipi_clk/2 */
	0x03, 0x1a, 0x00, /* MUST, tx clk = clk_src/4=mipi_clk/8 */
	0x02, 0x1a, 0x00, /* Fp clk = clk_src = mipi_clk/2,  max Fp_clk < 250MHz */
	/* mipi_clk = 12*(8+2+0)/1/1= 120 (MHz) */
	0x04, 0x26, 0x00,
	0x04, 0x15, 0x00, /* DSI_RG_CMU_PREDV = 0 */
	0x04, 0x24, 0x00, /* DSI_RG_CMU_PSTDV = 0, bypass PstDV */
	0x04, 0x2E, 0x00, /*  bypass PstDV */
	0x04, 0x34, 0x00, /* DSI_RG_SSC_FC =0 */
	0x04, 0x35, 0x00,
	0x04, 0x36, 0x08, /* DSI_RG_SSC_NC = 8 -->  mipi_clk = 120MHz[10/12] */
	0x04, 0x37, 0x00,
	/* Assume Pclk*16 < Tx_clk *8 * lane_num, when raw10 */
	/* Pclk = fp_clk*Frame_width/((Frame_width*(speed_div+1)/(speed_mul+1)+dummy_pix) */
	0x02, 0x00, 0x0A, /* frame width 1280  [10/11] */
	0x02, 0x01, 0x00,
	0x02, 0x02, 0x02, /* frame height 720 */
	0x02, 0x03, 0xD0,
	0x02, 0x04, 0x05, /* dumy pixel 1424 */
	0x02, 0x05, 0x90,
	0x02, 0x06, 0x00, /* dumy line 20 */
	0x02, 0x07, 0x14,
	0x02, 0x08, 0x00, /* speed 0 */
	0x02, 0x09, 0x00,
	/* Tx timing control */
	0x03, 0x03, 0x00, /* TX init time */
	0x03, 0x04, 0x31,
	0x03, 0x05, 0x04, /* HS exit time,[4/10] */
	0x03, 0x06, 0x03, /* Tx LPx time,[4/10] */
	0x03, 0x07, 0x0D, /* CK post time */
	0x03, 0x08, 0x09, /* CK prepare time */
	0x03, 0x09, 0x1D, /* CK zero time */
	0x03, 0x0A, 0x01, /* CK pre time */
	0x03, 0x0B, 0x03, /* HS prepare time,[4/10] */
	0x03, 0x0C, 0x03, /* HS zero time,[4/10] */
	0x03, 0x0D, 0x03, /* HS trail time,[4/10] */
	0x03, 0x0E, 0x02, /* Tx valid time,[4/10] */
	/* Tx control */
	0x03, 0x0F, 0x00, /* Tx IF CFG0, enable LANE */
	0x03, 0x01, 0x00, /* MIPI tx data raw8 ,[4/16] */
	0x03, 0x02, 0x03, /* Lane0/1 enable */
	0x03, 0x11, 0x00, /* data from fix pattern */
	0x03, 0x17, 0x01, /* 2 lane */
	0x03, 0x18, 0xE4,
	0x03, 0x19, 0x1E, /* set DI as 0x18 (YUV422 / 8bit), [4/16] */
	0x04, 0x18, 0x07, /* set HS amp to 440mV */
	0x03, 0x00, 0x01, /* Tx enable */
	/* pattern run */
	0x02, 0x11, 0x80, /* start x, y, [4/9] */
	0x02, 0x12, 0xff,
	0x02, 0x13, 0x00,
	0x02, 0x14, 0xd0, /* width, height, [4/9] */
	0x02, 0x15, 0xd0,
	0x02, 0x16, 0x11,
	0x02, 0x17, 0x20, /* Margin, [4/9] */
	0x02, 0x18, 0x20,
	0x02, 0x19, 0x00,
	0x02, 0x10, 0xC0, /* fixed pattern start,YUV2, 24 color,[4/16] */
};

/* RLE0551C 1280x720p30 RAW10 2Lane */
const unsigned char fw_rle0551_1280x720_raw10[] = {
	0x04, 0x2a, 0x00,
	0x04, 0x10, 0x00, /* Bad gap On */
	0x04, 0x09, 0x01, /* Tx PLL On, post-div disable */
	0x04, 0x00, 0x01, /* Tx analog power on */
	0x04, 0x67, 0x00, /* clk_src = mipi_clk/2 */
	0x03, 0x1a, 0x00, /* MUST, tx clk = clk_src/4=mipi_clk/8 */
	0x02, 0x1a, 0x00, /* Fp clk = clk_src = mipi_clk/2,  max Fp_clk < 250MHz */
	/* Configure PLL mipi clock  */
	0x04, 0x26, 0x00,
	0x04, 0x15, 0x00, /* DSI_RG_CMU_PREDV = 0 */
	0x04, 0x24, 0x00, /* DSI_RG_CMU_PSTDV = 0, bypass PstDV */
	0x04, 0x2E, 0x00, /* bypass PstDV */
	0x04, 0x34, 0x00, /* DSI_RG_SSC_FC =0 */
	0x04, 0x35, 0x00,
	0x04, 0x36, 0x0A, /* DSI_RG_SSC_NC = 10 -->  mipi_clk = 144MHz[10/12] */
	0x04, 0x37, 0x00,
	/* fixed pattern model configuration */
	0x02, 0x00, 0x05, /* frame width 1280  [10/11] */
	0x02, 0x01, 0x00,
	0x02, 0x02, 0x02, /* frame height 720 */
	0x02, 0x03, 0xD0,
	0x02, 0x04, 0x07, /* dumy pixel 1964 */
	0x02, 0x05, 0xAC,
	0x02, 0x06, 0x00, /* dumy line 20 */
	0x02, 0x07, 0x14,
	0x02, 0x08, 0x00, /* speed 0 */
	0x02, 0x09, 0x00,
	/* Tx timing control */
	0x03, 0x03, 0x00, /* TX init time */
	0x03, 0x03, 0x31,
	0x03, 0x05, 0x04, /* HS exit time,[4/10] */
	0x03, 0x06, 0x03, /* Tx LPx time,[4/10] */
	0x03, 0x07, 0x0D, /* CK post time */
	0x03, 0x08, 0x09, /* CK prepare time */
	0x03, 0x09, 0x1D, /* CK zero time */
	0x03, 0x0A, 0x01, /* CK pre time */
	0x03, 0x0B, 0x03, /* HS prepare time,[4/10] */
	0x03, 0x0C, 0x03, /* HS zero time,[4/10] */
	0x03, 0x0D, 0x03, /* HS trail time,[4/10] */
	0x03, 0x0E, 0x02, /* Tx valid time,[4/10] */
	/* Tx control */
	0x03, 0x0F, 0x00, /* Tx IF CFG0, enable LANE */
	0x03, 0x01, 0x01, /* MIPI tx data raw10 ,[10/11] */
	0x03, 0x02, 0x03, /* Lane0/1 enable */
	0x03, 0x11, 0x00, /* data from fix pattern */
	0x03, 0x17, 0x01, /* 2 lane */
	0x03, 0x18, 0xE4,
	0x03, 0x19, 0x2B, /* set DI as 0x2B, raw8, [10/11] */
	0x04, 0x18, 0x07, /* set HS amp to 440mV */
	0x03, 0x00, 0x01, /* Tx enable */
	/* pattern run */
	0x02, 0x11, 0x80, /* start x, y, [4/9] */
	0x02, 0x12, 0xff,
	0x02, 0x13, 0x00,
	0x02, 0x14, 0xd0, /* width, height, [4/9] */
	0x02, 0x15, 0xd0,
	0x02, 0x16, 0x11,
	0x02, 0x17, 0x20, /* argin, [4/9] */
	0x02, 0x18, 0x20,
	0x02, 0x19, 0x00,
	0x02, 0x10, 0xC0, /* fixed pattern start,YUV2, 24 color,[4/16] */
};

void RLE0551C_2048x1536(void)
{
	struct i2c_adapter *p_adap;
	unsigned int i;
	unsigned char data[3];

	pr_info("[HDMI RX] RLE0551C_2048x1536\n");
	p_adap = mipi_i2c_init();	
    
    if (p_adap == NULL) {
		pr_err("[HDMI RX][%s] Init i2c fail\n",__FUNCTION__);
		return;
    }

	for (i = 0; i < sizeof(fw_data_2048x1536); i += 3) {
		data[0]=fw_data_2048x1536[i];
		data[1]=fw_data_2048x1536[i+1];
		data[2]=fw_data_2048x1536[i+2];
		mipi_i2c_write(p_adap, 3, &data);
	}
}

void RLE0551C_1280x720_raw(void)
{
    struct i2c_adapter *p_adap;
    unsigned int i;
	unsigned char data[3];

    pr_info("[HDMI RX] %s\n", __func__);
    p_adap = mipi_i2c_init();	

    if (p_adap == NULL) {
        pr_err("[HDMI RX][%s] Init i2c fail\n", __func__);
        return;
    }

	for (i = 0; i < sizeof(fw_rle0551_1280x720_raw8); i += 3) {
		data[0]=fw_rle0551_1280x720_raw8[i];
		data[1]=fw_rle0551_1280x720_raw8[i+1];
		data[2]=fw_rle0551_1280x720_raw8[i+2];
		mipi_i2c_write(p_adap, 3, &data);
	}
}

void RLE0551C_1280x720_yuv2(void)
{
    struct i2c_adapter *p_adap;
    unsigned int i;
	unsigned char data[3];

    pr_info("[HDMI RX] %s\n", __func__);
    p_adap = mipi_i2c_init();	

    if (p_adap == NULL) {
        pr_err("[HDMI RX][%s] Init i2c fail\n", __func__);
        return;
    }

	for (i = 0; i < sizeof(fw_rle0551_1280x720_yuv2); i += 3) {
		data[0]=fw_rle0551_1280x720_yuv2[i];
		data[1]=fw_rle0551_1280x720_yuv2[i+1];
		data[2]=fw_rle0551_1280x720_yuv2[i+2];
		mipi_i2c_write(p_adap, 3, &data);
	}
}


