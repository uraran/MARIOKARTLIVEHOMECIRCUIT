#! /usr/bin/perl -w
if( defined(@ARGV) )
{
	foreach $arg (@ARGV) {
		($type, $file) = split(/=/, $arg);
		if ($type eq "rsa_pub_key") {
			$rsa_pub_key = $file;
		} elsif ($type eq "aes_key") {
			$aes_key = $file;
		} elsif ($type eq "aes_seed") {
			$aes_seed = $file;
		} elsif ($type eq "pocono_key") {
			$pocono_key = $file;
		} elsif ($type eq "user_part_key") {
			$user_part_key = $file;
		} elsif ($type eq "cust_data") {
			$cust_data = $file;
		} 
	}

    open BINARY, $rsa_pub_key or die $!;

    # in the for();
    # (map ord, split //, $bytes) will generate a list
    # $byte is stream data read from file
    # (split //, $byte) will separate $byte into char list (maybe)
    # map will apply ord (to number) to each one in char list
    # then each result after map will put in "$_"


    my $bytes;
    $current = 0;
    $size = -s BINARY;
    ($size>>=2); # word number -1
    print ".data\n.globl rsa_pub_key\n.globl rsa_pub_key_end\nrsa_pub_key:\n.word \\\n";
    while ($current < $size)
    {
        read(BINARY, $bytes, 1);
        @a = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @b = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @c = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @d = map ord, split //, $bytes;
        
        #need not inverse, if we use SCPU(ARM) write data to EFUSE, and use Rbus read it, both ACPU & SCPU will see little endian value
        printf "0x%02x", @d;
        printf "%02x", @c;
        printf "%02x", @b;
        printf "%02x", @a;

        $current++;
        if($current < $size)
        { print ","}
        else
        { last }

        if($current%4==0)
        { print "\\\n";}
    }
    print "\nrsa_pub_key_end:\n.word 0\n";
    
    open BINARY, $aes_key or die $!;

    # in the for();
    # (map ord, split //, $bytes) will generate a list
    # $byte is stream data read from file
    # (split //, $byte) will separate $byte into char list (maybe)
    # map will apply ord (to number) to each one in char list
    # then each result after map will put in "$_"


    $current = 0;
    $size = -s BINARY;
    ($size>>=2); # word number -1
    print ".data\n.globl aes_key\n.globl aes_key_end\naes_key:\n.word \\\n";
    while ($current < $size)
    {
#        read(BINARY, $bytes, 4);
#        @a = map ord, split //, $bytes;
#        printf "0x%02x%02x%02x%02x", @a;

        read(BINARY, $bytes, 1);
        @a = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @b = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @c = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @d = map ord, split //, $bytes;
        
        #printf "0x%02x", @a;
        #printf "%02x", @b;
        #printf "%02x", @c;
        #printf "%02x", @d;

        #need inverse, if we use SCPU(ARM) write data to EFUSE, for CP read it
        printf "0x%02x", @d;
        printf "%02x", @c;
        printf "%02x", @b;
        printf "%02x", @a;
       
        $current++;
        if($current < $size)
        { print ","}
        else
        { last }

        if($current%4==0)
        { print "\\\n";}
    }
    print "\naes_key_end:\n.word 0\n";
    
    
    

    open BINARY, $aes_seed or die $!;

    # in the for();
    # (map ord, split //, $bytes) will generate a list
    # $byte is stream data read from file
    # (split //, $byte) will separate $byte into char list (maybe)
    # map will apply ord (to number) to each one in char list
    # then each result after map will put in "$_"


    $current = 0;
    $size = -s BINARY;
    ($size>>=2); # word number -1
    print ".data\n.globl aes_seed\n.globl aes_seed_end\naes_seed:\n.word \\\n";
    while ($current < $size)
    {
#        read(BINARY, $bytes, 4);
#        @a = map ord, split //, $bytes;
#        printf "0x%02x%02x%02x%02x", @a;

        read(BINARY, $bytes, 1);
        @a = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @b = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @c = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @d = map ord, split //, $bytes;
        
        #printf "0x%02x", @a;
        #printf "%02x", @b;
        #printf "%02x", @c;
        #printf "%02x", @d;

        #need inverse, if we use SCPU(ARM) write data to EFUSE, for CP read it
        printf "0x%02x", @d;
        printf "%02x", @c;
        printf "%02x", @b;
        printf "%02x", @a;
       
        $current++;
        if($current < $size)
        { print ","}
        else
        { last }

        if($current%4==0)
        { print "\\\n";}
    }
    print "\naes_seed_end:\n.word 0\n";





    open BINARY, $pocono_key or die $!;

    # in the for();
    # (map ord, split //, $bytes) will generate a list
    # $byte is stream data read from file
    # (split //, $byte) will separate $byte into char list (maybe)
    # map will apply ord (to number) to each one in char list
    # then each result after map will put in "$_"


    $current = 0;
    $size = -s BINARY;
    ($size>>=2); # word number -1
    print ".data\n.globl pocono_key\n.globl pocono_key_end\npocono_key:\n.word \\\n";
    while ($current < $size)
    {
#        read(BINARY, $bytes, 4);
#        @a = map ord, split //, $bytes;
#        printf "0x%02x%02x%02x%02x", @a;

        read(BINARY, $bytes, 1);
        @a = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @b = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @c = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @d = map ord, split //, $bytes;

        #printf "0x%02x", @a;
        #printf "%02x", @b;
        #printf "%02x", @c;
        #printf "%02x", @d;

        #need inverse, if we use SCPU(ARM) write data to EFUSE, for CP read it
        printf "0x%02x", @d;
        printf "%02x", @c;
	printf "%02x", @b;
        printf "%02x", @a;

        $current++;
        if($current < $size)
        { print ","}
        else
        { last }

        if($current%4==0)
        { print "\\\n";}
    }
    print "\npocono_key_end:\n.word 0\n";




    open BINARY, $user_part_key or die $!;

    # in the for();
    # (map ord, split //, $bytes) will generate a list
    # $byte is stream data read from file
    # (split //, $byte) will separate $byte into char list (maybe)
    # map will apply ord (to number) to each one in char list
    # then each result after map will put in "$_"


    $current = 0;
    $size = -s BINARY;
    ($size>>=2); # word number -1
    print ".data\n.globl user_part_key\n.globl user_part_key_end\nuser_part_key:\n.word \\\n";
    while ($current < $size)
    {
#        read(BINARY, $bytes, 4);
#        @a = map ord, split //, $bytes;
#        printf "0x%02x%02x%02x%02x", @a;

        read(BINARY, $bytes, 1);
        @a = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @b = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @c = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @d = map ord, split //, $bytes;

        #printf "0x%02x", @a;
        #printf "%02x", @b;
        #printf "%02x", @c;
        #printf "%02x", @d;

        #need inverse, if we use SCPU(ARM) write data to EFUSE, for CP read it
        printf "0x%02x", @d;
        printf "%02x", @c;
        printf "%02x", @b;
        printf "%02x", @a;

        $current++;
        if($current < $size)
        { print ","}
        else
        { last }

        if($current%4==0)
        { print "\\\n";}
    }
    print "\nuser_part_key_end:\n.word 0\n";




    if(defined $cust_data)
    {
      open BINARY, $cust_data ;

    # in the for();
    # (map ord, split //, $bytes) will generate a list
    # $byte is stream data read from file
    # (split //, $byte) will separate $byte into char list (maybe)
    # map will apply ord (to number) to each one in char list
    # then each result after map will put in "$_"


      $current = 0;
      $size = -s BINARY;
      ($size>>=2); # word number -1
      print ".data\n.globl cust_data\n.globl cust_data_end\ncust_data:\n.word \\\n";
      while ($current < $size)
      {
#        read(BINARY, $bytes, 4);
#        @a = map ord, split //, $bytes;
#        printf "0x%02x%02x%02x%02x", @a;

        read(BINARY, $bytes, 1);
        @a = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @b = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @c = map ord, split //, $bytes;
        read(BINARY, $bytes, 1);
        @d = map ord, split //, $bytes;
        
        #printf "0x%02x", @a;
        #printf "%02x", @b;
        #printf "%02x", @c;
        #printf "%02x", @d;

        #need inverse, if we use SCPU(ARM) write data to EFUSE, for CP read it
        printf "0x%02x", @d;
        printf "%02x", @c;
        printf "%02x", @b;
        printf "%02x", @a;
       
        $current++;
        if($current < $size)
        { print ","}
        else
        { last }

        if($current%4==0)
        { print "\\\n";}
      }
      print "\ncust_data_end:\n.word 0\n";
    }
}
else
{
    print "binary image file need!! \n";
}
